# -*- coding: utf-8 -*-
"""KolAndSha.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ryVN65_t5csXfugDWj7az7_UBhY806AT

Importando bibliotecas
---
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import scipy.stats as st
import pandas as pd
import numpy as np
from scipy.special import erf
from scipy.stats import norm
import seaborn as sns
import matplotlib.pyplot as plt
import os
from scipy import stats
import warnings
from scipy.stats import anderson
warnings.simplefilter(action="ignore", category=FutureWarning)
# %matplotlib inline

master9 = pd.read_csv("valoresCriticosShapiro.csv")
master9

master8 = pd.read_csv("p_mensal_avioes.csv")
master8

master7 = pd.read_csv("maquinaAgric2.csv")
master7

master6 = pd.read_csv("kolmogorovCriticalvalues.csv")
master6

master5 = pd.read_csv("coeficientesShapiro.csv")
master5

master4 = pd.read_csv("ValoresCriticosdoW.csv")
master4

master3 = pd.read_csv("TabelaH1.csv")
master3

master2 = pd.read_csv("ValoresCriticosdeD.csv")
master2

master = pd.read_csv("maquinaAgric2.csv")
master

"""##  KOLMOGOROV-SMIRNOV"""

# Função de Distribuição Cumulativa (CDF) para uma distribuição normal
def cdf_normal(x, mean, std):
    return 0.5 * (1 + erf((x - mean) / (std * np.sqrt(2))))

# Função para realizar o teste de Kolmogorov-Smirnov
def KolmogorovSmirnov(rol, alpha, tamanho,graf = True):
    # Cálculo de estatísticas descritivas
    Media = rol.mean()
    Variancia = rol.var()
    DesvioPadrao = rol.std()
    mediana = np.median(rol)
    min = rol.min()
    maximum = rol.max()
    soma = rol.sum()

    if graf:
        print('Media = ',Media)
        print('Variancia = ',Variancia)
        print('DesvioPadrao = ',DesvioPadrao)
        print("Mediana = ",mediana)
        print("Minimo = ",min)
        print("Maximo = ",maximum)
        print("Soma = ",soma)
        print("Contagem = ",tamanho)

    # Inicializa uma tabela para armazenar os cálculos
    Tabela = pd.DataFrame(columns=['xi', 'Fobs', 'Fa', 'Fra', 'zcalc', 'fesp', '|fesp(xi) - fra(xi)|', '|fesp(xi) - fra(xi-1)|'])

    # Define uma tabela de valores críticos para o teste K-S
    tabG = {'0.20': 1.07 / np.sqrt(tamanho), '0.15': 1.14 / np.sqrt(tamanho), '0.10': 1.22 / np.sqrt(tamanho),
            '0.05': 1.36 / np.sqrt(tamanho), '0.025': 1.48 / np.sqrt(tamanho), '0.01': 1.63 / np.sqrt(tamanho),
            '0.005': 1.73 / np.sqrt(tamanho)}

    # Calcula frequências e estatísticas relevantes
    Tabela['xi'], Tabela['Fobs'] = np.unique(rol, return_counts=True)
    Tabela['Fa'] = Tabela['Fobs'].cumsum()
    Tabela['Fra'] = Tabela['Fa'] / Tabela['Fobs'].sum()
    Tabela['zcalc'] = (Tabela['xi'] - Media) / DesvioPadrao
    Tabela['fesp'] = norm.cdf(Tabela['zcalc'])
    Tabela['|fesp(xi) - fra(xi)|'] = abs(Tabela['fesp'] - Tabela['Fra'])
    Tabela['|fesp(xi) - fra(xi-1)|'] = abs(Tabela['fesp'] - Tabela['Fra'].shift(1))
    Tabela.loc[0, '|fesp(xi) - fra(xi-1)|'] = abs(Tabela.loc[0, 'fesp'] - 0)

    # Calcula a estatística K-S
    Dcalc = max(abs(Tabela['|fesp(xi) - fra(xi)|'].max()), abs(Tabela['|fesp(xi) - fra(xi-1)|'].max()))

    # Obtém o valor crítico correspondente ao tamanho da amostra
    if tamanho <= 30:
        Dtab = tabG[str(alpha)]
    else:
        Dtab = tabG[str(alpha)]


    # Teste de hipóteses
    if Dcalc < Dtab:
        print('\nDcalc < Dtab --> Aceita H0')
    else:
        print('\nDcalc > Dtab --> Rejeita H0')

    # Realiza o teste de confiabilidade
    anderson_result = anderson(rol, dist='norm')
    ad_statistic = anderson_result.statistic
    ad_critical_values = anderson_result.critical_values
    ad_significance_level = anderson_result.significance_level

    print(f'\nTest para Confiabilidade:')
    print(f'Estatística de Teste: {ad_statistic}')
    print(f'Valores Críticos: {ad_critical_values}')
    print(f'Níveis de Significância: {ad_significance_level}')

    if ad_statistic < ad_critical_values[2]:
        print(f'O teste sugere que os dados podem seguir uma distribuição normal (nível de significância de 5%).')
    else:
        print(f'O teste sugere que os dados podem não seguir uma distribuição normal (nível de significância de 5%).')

    # Retorna a tabela com os cálculos
    return Tabela

# Leitura do arquivo CSV
dados = pd.read_csv('maquinaAgric2.csv', usecols=['Faturamento'])
data = dados['Faturamento']

# Cálculos de estatísticas básicas
media = data.mean()
erro_padrao = data.sem()
desvio_padrao = data.std()
variancia_amostral = data.var()
minimo = data.min()
soma_total = data.sum()
contagem_observacoes = len(data)


# Obtendo o valor crítico correspondente ao tamanho da amostra
kolmogorov_critical_values = pd.read_csv('kolmogorovCriticalvalues.csv', index_col=0)
n = 10  # Substitua pelo tamanho da sua amostra
alpha = 0.05  # Substitua pelo nível de significância desejado
critical_value = kolmogorov_critical_values.loc[kolmogorov_critical_values.index == n, f'{alpha}'].values[0]

# Avaliação do resultado do teste de hipóteses
if d_statistic <= critical_value:
    print(f'Resultado do Teste: Não rejeitamos a hipótese nula (H0)')
else:
    print(f'Resultado do Teste: Rejeitamos a hipótese nula (H0)')

# Chama a função KolmogorovSmirnov
alpha = 0.05
tamanho_amostra = len(data)
KolmogorovSmirnov(data, alpha, tamanho_amostra)

"""## ShapiroWilk"""

# Define a classe ShapiroWilkTest
class ShapiroWilkTest:
    def __init__(self, data_filename, target_column, alpha):
        self.alpha = alpha
        self.data = pd.read_csv(data_filename)  # Lê um arquivo CSV de dados
        self.target_column = target_column
        self.df = pd.DataFrame()  # Cria um DataFrame vazio chamado "df" para armazenar os valores
        self.prepare_data()  # Chama a função para preparar os dados

    # Função para preparar os dados
    def prepare_data(self):
        n = len(self.data)  # Obtém o comprimento dos dados
        # Cria colunas no DataFrame com base em operações com os dados
        self.df["i"] = [i for i in range(1, (n // 2) + 1)]
        self.df["n-(i-1)"] = [n - i + 1 for i in range(1, (n // 2) + 1)]
        self.df["a_i,n"] = [coeficientes[str(n)][i] for i in range(0, len(self.df))]  # Consulta a tabela coeficientes
        self.df["X_(n-i+1)"] = [self.data[self.target_column][n - i + 1] for i in range(2, len(self.df) + 2)]
        self.df["X_i"] = [self.data[self.target_column][i] for i in range(0, len(self.df))]
        self.df["a_i,n (X_(n-i+1) - X_i)"] = self.df["a_i,n"] * (self.df["X_(n-i+1)"] - self.df["X_i"])

    # Função para executar o teste de Shapiro-Wilk
    def run_test(self):
        media = self.data[self.target_column].mean()  # Calcula a média dos dados
        b = sum(self.df["a_i,n (X_(n-i+1) - X_i)"])  # Calcula a soma de uma coluna do DataFrame
        w_calc = (b ** 2) / (sum((xi - media) ** 2 for xi in self.data[self.target_column]))  # Calcula w_calc
        w_crit = criticos[str(self.alpha)][len(self.data) - 3]  # Obtém o valor crítico de acordo com o tamanho dos dados

        # Imprime informações sobre o teste e os resultados
        print("\n----------- Tabela: Shapiro-Wilk -----------")
        print(self.df)
        print("\nWcalculado:", round(w_calc, 3))
        print("WCritico:", round(w_crit, 3))

        # Verifica se os dados seguem uma distribuição normal com base nos resultados do teste
        if w_calc > w_crit:
            print(" --> A variável NAO Segue uma Distribuicao Normal <--")
        else:
            print(" --> A variável Segue uma Distribuicao Normal <--")

        # Novo código adicionado
        if w_calc >= w_crit:
            print('\nWcalc >= Wc --> Aceita H0')
        else:
            print('\nWcalc < Wc --> Rejeita H0')

        # Imprime outras estatísticas dos dados
        print('Media = ', media)
        print('Variancia = ', self.data[self.target_column].var())
        print('DesvioPadrao = ', self.data[self.target_column].std())
        print("Mediana = ", self.data[self.target_column].median())

        print('Max = ', self.df['X_i'].max())
        print('Min = ', self.df['X_i'].min())
        print("Soma = ", self.df['X_i'].sum())
        print("Contagem = ", len(self.data))
        print('Wcalc = ', w_calc)
        print('Wc = ', w_crit)

# Lendo os arquivos CSV
coeficientes = pd.read_csv("coeficientesShapiro.csv", na_values="NA")  # Lê um arquivo CSV com coeficientes
criticos = pd.read_csv("valoresCriticosShapiro.csv")  # Lê um arquivo CSV com valores críticos

# Criando uma instância da classe e chamando o método run_test
sw = ShapiroWilkTest("p_mensal_avioes.csv", "prodAvioes", 0.01)  # Cria uma instância da classe
sw.run_test()  # Chama a função para executar o teste de Shapiro-Wilk